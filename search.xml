<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>為什麼 RD 給的 Android App Bundle 連結不能用！</title>
    <url>/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/</url>
    <content><![CDATA[<html><head></head><body><h2 id="前言故事" class="heading-control"><a href="#前言故事" class="headerlink" title="前言故事"></a>前言故事<a class="heading-anchor" href="#前言故事" aria-hidden="true"></a></h2><p>星期三的下午，負責小威團隊的 PM，匆忙的跑到小威的座位旁，問到：「小威～ 為什麼你剛剛給我的連結不能用啊！」</p>
<p>小威回問道：「什麼安裝連結？」</p>
<p>PM：「就是那個新版 App 的安裝連結啊～」說完，給小威看他手機上的畫面：</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/BoxECeCH4sg" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>原來自從小威團隊轉用 <a href="https://developer.android.com/platform/technology/app-bundle">Android App Bundle 技術</a> 打包產品後，由原本直接傳送 APK 發佈更新，改為使用 <a href="https://play.google.com/console/about/internalappsharing/">Internal App Sharing</a> 的方式發佈。新的發佈方式會產生一個安裝用連結，在手機上點擊後，Google Play 會自動開啟安裝畫面。</p>
<p>雖然聽起來簡單簡單，但是用起來真是問題不斷，其中最常見的就是上面這種「內部應用程式分享功能已關閉」，連結點開後，跳出不知所謂的訊息 😕！不但訊息沒幫助，上面的連結更是沒幫助！只能說 Google 工程、技術邏輯一流，但人性化上真是有待加強 🤖</p>
<h2 id="開啟關鍵開關" class="heading-control"><a href="#開啟關鍵開關" class="headerlink" title="開啟關鍵開關"></a>開啟關鍵開關<a class="heading-anchor" href="#開啟關鍵開關" aria-hidden="true"></a></h2><p>其實上述的訊息，只是想講一件事！這位 PM，你沒有開啟一個關鍵開關！</p>
<p>小威接著解釋到，該如何開啟：</p>
<ol>
<li><p>開啟 Google Play</p>
<img src="/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/1119_1.png" class="slug">
</li>
<li><p>點選左上角的漢堡選單</p>
<img src="/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/1119_2.png" class="slug">
</li>
<li><p>找到設定，點開進去</p>
<img src="/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/1119_3.png" class="slug">
</li>
<li><p>滑到最下面，應該會看到「Play 商店版本」</p>
<img src="/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/1119_4.png" class="slug">
</li>
<li><p>點它，一直點到「你已啟用開發人員設定」的訊息跳出</p>
<img src="/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/1119_5.png" class="slug">
</li>
<li><p>接著找到「內部應用程式分享」，開啟它</p>
<img src="/%E7%82%BA%E4%BB%80%E9%BA%BC-RD-%E7%B5%A6%E7%9A%84-Android-%E6%B8%AC%E8%A9%A6%E9%80%A3%E7%B5%90%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%81/1119_6.png" class="slug">

</li>
</ol>
<p>噹噹～ 搞定</p>
<div class="note danger">
            <p>‼️ 特別提醒，開啟內部應用程式分享，代表你可以透過連結安裝別人的程式。所以小威還是要提醒各位，不要點選或安裝你不知道的安裝連結！‼️</p>
          </div>

<div>
    
        <div style="text-align:left;font-size:1em;">
<p style="text-align:center;color: #ccc;">------------- 本文结束 <i class="far fa-question-circle"></i> UI 人性化比實質功能更重要啊 -------------</p>
        </div>
    
</div></body></html>]]></content>
      <categories>
        <category>小威</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>git submodule 的分支追蹤</title>
    <url>/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/</url>
    <content><![CDATA[<html><head></head><body><h2 id="前言故事" class="heading-control"><a href="#前言故事" class="headerlink" title="前言故事"></a>前言故事<a class="heading-anchor" href="#前言故事" aria-hidden="true"></a></h2><p>小威在一間資訊公司擔任 Android 軟體工程師，負責公司內的主力產品開發，這是一項功能複雜的產品，它累計了數年的程式碼、商務邏輯、出包經驗等的功能與修正。數年後，團隊中正在推動全新 2.0 的產品，以及公司其他服務也即將推出 App。不可避免的，有許多相似功能相繼橫跨各個產品 App，這讓小威自覺必須有一套更好的方式管理自己團隊的程式碼，改善之後擴充性、維護性，和保護團隊工程師們的肝～</p>
<p>一個從頭打造的產品，功能是不斷的疊加上去，鮮少有團隊能真的從開頭就搞好架構設計，小威團隊的產品也不例外。除了自身的核心功能外，還使用了圖隊之前開發的功能，以及許多現成 github 的模組，有的已提供 gradle 的安裝與使用，有的卻只是單純的 Java/Kotlin 程式碼。在初期，最直接暴力的方式就是直接抓下來，塞進當前的 App 中使用，累積到今時今日，已有數個相同模組，分別的複製到數個專案上 😱</p>
<p>小威團隊有幾個選擇：</p>
<ol>
<li>維持現狀，每個 App 複製一份程式碼<ul>
<li><strong>優點</strong>：現有架構、不需更改、各個 App 工程彈性自由，想怎麼改就怎麼改</li>
<li><strong>缺點</strong>：維上非常不便，一個修正需要同步到所有 App，之後工程師要記得去手動 merge 更新的程式碼</li>
</ul>
</li>
</ol>
<ol start="2">
<li>將可模組化的，改寫成 gradle<ul>
<li><strong>優點</strong>：不必要再包一份程式碼到各個 App，之後其他專案要使用會更便利。模組更新，只需要修改一份程式碼，gradle 版號升級便可更新程式</li>
<li><strong>缺點</strong>：之後各個 App 要做客製化，會相對不容易</li>
</ul>
</li>
</ol>
<ol start="3">
<li>將可模組化的，改成 submodule<ul>
<li><strong>優點</strong>：每個模組只需要維護一份程式碼，需要更新時，使用 git 內建方式，即可同步最新的程式。App 也有一定自由度去做產品客製化</li>
<li><strong>缺點</strong>：還是仰賴各 App 去 merge 更新，但不一定需要手動（透過 git 同步 submodule 即可）</li>
</ul>
</li>
</ol>
<p>最後，小威團隊選擇 submodule 模式去進行，以下是小威的手稿紀錄：</p>
<h2 id="將專案切分成-submodule" class="heading-control"><a href="#將專案切分成-submodule" class="headerlink" title="將專案切分成 submodule"></a>將專案切分成 submodule<a class="heading-anchor" href="#將專案切分成-submodule" aria-hidden="true"></a></h2><p>目前小威團隊負責的產品 git 架構如下，一個巨型 git repo，內容包山包海，含之前團隊開發的功能模組，以及第三方 github 的功能模組等：</p>
<img src="/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/app_diagram_1.svg" class title="產品架構圖 - 之前">

<p>重新打造後，新的 git 架構如下，可被多個產品共用的模組，都會拉成獨立的 git repo，由一個主要 git repo 來把其他功能，以 submodule 方式添加進來：</p>
<img src="/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/app_diagram_2.svg" class title="產品架構圖 - 之後">

<h3 id="加入-submodule-指令" class="heading-control"><a href="#加入-submodule-指令" class="headerlink" title="加入 submodule 指令"></a>加入 submodule 指令<a class="heading-anchor" href="#加入-submodule-指令" aria-hidden="true"></a></h3><p>以下用其中一個功能為範例。將 function1 以 submodule 方式加入主 App：</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git submodule add https://github.com/wm4n/function1.gitfunction1</span><br><span class="line">正複製到 <span class="string">'/Users/[path]/app-host/function1'</span>...</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">接收物件中: 100% (4/4), 完成.</span><br></pre></td></tr></tbody></table></figure>

<p>以上指令會將 function1 repo 內容抓到 function1 目錄下，如果印出 .gitmodules 檔案（使用 <code>git submodule add</code> 後自動建立）內容，會發現：</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"function1"</span>]</span><br><span class="line">	path = function1</span><br><span class="line">	url = https://github.com/wm4n/function1.git</span><br></pre></td></tr></tbody></table></figure>

<h3 id="上傳添加的-submodule" class="heading-control"><a href="#上傳添加的-submodule" class="headerlink" title="上傳添加的 submodule"></a>上傳添加的 submodule<a class="heading-anchor" href="#上傳添加的-submodule" aria-hidden="true"></a></h3><p>照平常 git 使用的方式，將添加好的 submodule 設定，上傳至 github</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git add .gitmodules</span><br><span class="line"></span><br><span class="line">❯ git add function1</span><br><span class="line"></span><br><span class="line">❯ git commit -m <span class="string">"add function1 submodule"</span></span><br><span class="line">[main 26d42dc] add function1 submodule</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 function1</span><br><span class="line"></span><br><span class="line">❯ git push</span><br><span class="line">枚舉物件: 4, 完成.</span><br><span class="line">物件計數中: 100% (4/4), 完成.</span><br><span class="line">使用 4 個執行緒進行壓縮</span><br><span class="line">壓縮物件中: 100% (3/3), 完成.</span><br><span class="line">寫入物件中: 100% (3/3), 419 位元組 | 419.00 KiB/s, 完成.</span><br><span class="line">總共 3 (差異 0)，復用 0 (差異 0)，重用包 0</span><br><span class="line">To https://github.com/wm4n/app-host.git</span><br><span class="line">   278058e..26d42dc  main -> main</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更新-repo-內容" class="heading-control"><a href="#更新-repo-內容" class="headerlink" title="更新 repo 內容"></a>更新 repo 內容<a class="heading-anchor" href="#更新-repo-內容" aria-hidden="true"></a></h3><p>當要同步線上程式碼時，一般會用 <code>git pull</code> 來抓取最新內容，但改用 submodule 方式後，會發現 function1 不會同步。如果要更新，則必須進入到 function1 目錄下再次執行 <code>git pull</code></p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> function1</span><br><span class="line"></span><br><span class="line">❯ git pull</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">展開物件中: 100% (3/3), 691 位元組 | 138.00 KiB/s, 完成.</span><br><span class="line">來自 https://github.com/wm4n/function1</span><br><span class="line">   5f9ae22..e6843b4  main       -> origin/main</span><br><span class="line">更新 5f9ae22..e6843b4</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="當-submodule-數量成長後" class="heading-control"><a href="#當-submodule-數量成長後" class="headerlink" title="當 submodule 數量成長後"></a>當 submodule 數量成長後<a class="heading-anchor" href="#當-submodule-數量成長後" aria-hidden="true"></a></h3><p>小威團隊負責的產品，如今被拆解成 5 個 submodule 後，發現今後如果要更新，就要進入每個 submodule 的目錄，分別執行 <code>git pull</code> 指令，這表示一個專案如果有 X 個 submodule，每次更新最多就會有 X + 1 個 <code>git pull</code>。這不僅讓小威受不了，團隊也常為了忘記要確實執行，反而造成許多問題。</p>
<p>為了改善這問題，小威在模組設定檔中，<strong>指定讓模組 submodule 追蹤某個特定的遠端分支</strong></p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"function1"</span>]</span><br><span class="line">	path = function1</span><br><span class="line">	url = https://wm4n@github.com/wm4n/function1.git</span><br><span class="line">	branch = main</span><br></pre></td></tr></tbody></table></figure>

<p>branch 代表這個 submodule 將追蹤指定的遠端分支。之後，團隊只要使用 <code>git submodule update --remote</code> 指令<strong>一次</strong>，所有的 submodule 都會依照指定的<strong>分支</strong>去抓最新的內容，如下：</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git submodule update --remote</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">展開物件中: 100% (3/3), 689 位元組 | 344.00 KiB/s, 完成.</span><br><span class="line">來自 https://github.com/wm4n/function1</span><br><span class="line">   e6843b4..c7df259  main       -> origin/main</span><br><span class="line">子模組路徑 <span class="string">'function1'</span>：檢出 <span class="string">'c7df259c57f4c6143c4e29488399b13b9fb188c6'</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="令人分心的-git-status" class="heading-control"><a href="#令人分心的-git-status" class="headerlink" title="令人分心的 git status"></a>令人分心的 git status<a class="heading-anchor" href="#令人分心的-git-status" aria-hidden="true"></a></h3><p>一切設定好，分支追蹤功能滿足了團隊的需求，從此之後，可重複使用的功能順利地抽出成獨立 git repo，不同 App 依照各自需求，添加自己需要的 submodule，然後一鍵更新所有模組也不再是夢想 🥳。一切是如此的美好，直到團隊發現… 經常 <code>git status</code>，就會出現：</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git status</span><br><span class="line">位於分支 main</span><br><span class="line">您的分支與上游分支 <span class="string">'origin/main'</span> 一致。</span><br><span class="line"></span><br><span class="line">尚未暫存以備提交的變更：</span><br><span class="line">  （使用 <span class="string">"git add <檔案>..."</span> 更新要提交的內容）</span><br><span class="line">  （使用 <span class="string">"git restore <檔案>..."</span> 捨棄工作區的改動）</span><br><span class="line">	修改：     function1 (新提交)</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">"git add"</span> 和/或 <span class="string">"git commit -a"</span>）</span><br></pre></td></tr></tbody></table></figure>

<p>在使用分支追蹤之前，小威的團隊總是會在跟新模組後，緊接著跟新主 App 的模組 commit ID。使用分支追蹤後，雖然不必要再跟新模組 commit ID（因為 <code>git submodule update --remote</code> 指令會自動同步分支最新的 commit ID），但 <code>git status</code> 指令還是會提醒有更新尚未提交。久而久之，團隊都覺得這訊息實在惱人啊～ 😖</p>
<p>小威試了數個方式後，包括把相關檔案都加到 <code>.gitignore</code>（此方法無效），最後是在模組設定中，加上 <code>ignore = all</code>，就搞定了：</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"function1"</span>]</span><br><span class="line">	path = function1</span><br><span class="line">	url = https://wm4n@github.com/wm4n/function1.git</span><br><span class="line">	branch = main</span><br><span class="line">	ignore = all</span><br></pre></td></tr></tbody></table></figure>

<h3 id="對-github-上的第三方專案做客製化" class="heading-control"><a href="#對-github-上的第三方專案做客製化" class="headerlink" title="對 github 上的第三方專案做客製化"></a>對 github 上的第三方專案做客製化<a class="heading-anchor" href="#對-github-上的第三方專案做客製化" aria-hidden="true"></a></h3><p>沒多久後，小威團隊發現，他們想對 github 上的第三方專案做客製化，以符合規格需求，但要如何追蹤 github 專案分支的同時，又做客製化呢？畢竟無法對第三方的專案做修改（除非經由 PR 流程，但一般來說不會接受客製化…）</p>
<p>小威團隊利用 github fork 專案的方式，讓自己的專案轉追蹤 fork 的拷貝，利用 fork 拷貝來做客製化，同時又能<a href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/syncing-a-fork">不斷從 upstream 專案中更新</a></p>
<hr>
<p>從此之後，<code>git status</code> 也不再困擾小威團隊了 🥳</p>
<p><strong>相關連結：</strong><a href="https://github.com/wm4n/app-host"><i class="fab fa-github"></i> Demo 專案</a></p>
<div>
    
        <div style="text-align:left;font-size:1em;">
<p style="text-align:center;color: #ccc;">------------- 本文结束 <i class="fab fa-git-alt"></i> git 就是這麼的難搞！-------------</p>
        </div>
    
</div></body></html>]]></content>
      <categories>
        <category>小威</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>跳出方塊的 Android</title>
    <url>/%E8%B7%B3%E5%87%BA%E6%96%B9%E5%A1%8A%E7%9A%84-Android/</url>
    <content><![CDATA[<html><head></head><body><h2 id="前言故事" class="heading-control"><a href="#前言故事" class="headerlink" title="前言故事"></a>前言故事<a class="heading-anchor" href="#前言故事" aria-hidden="true"></a></h2><p>老皮是小威公司裡的好友，平常最愛的是，就是偷閒看幾本書，工作休息時，就會拉著小威，分享最近又從書裡學了哪招哪招，批評一下市面上產品、集團策略…。今天一早，老皮也是很興奮的跑來，小威本以為他又要講書裡的哪招，但沒想到老皮竟然掏出他的 Pixel 手機，說道：「你看看，我收集到這麼多的方塊和圈圈。」</p>
<p>小威好奇問：「什麼！什麼方塊和圈圈」</p>
<h2 id="App-通知的-icon-🟥-🔵-⬛️-🟤" class="heading-control"><a href="#App-通知的-icon-🟥-🔵-⬛️-🟤" class="headerlink" title="App 通知的 icon 🟥 🔵 ⬛️ 🟤"></a>App 通知的 icon 🟥 🔵 ⬛️ 🟤<a class="heading-anchor" href="#App-通知的-icon-🟥-🔵-⬛️-🟤" aria-hidden="true"></a></h2><p>老皮興奮地指著畫面上的方塊和圈圈：</p>
<img src="/%E8%B7%B3%E5%87%BA%E6%96%B9%E5%A1%8A%E7%9A%84-Android/1120_1.png" class="slug" width="324" height="666">

<p>「這是什麼！？」小威思考著 🤔，接著老皮把畫面解鎖，從畫面上方拉下了通知列表</p>
<img src="/%E8%B7%B3%E5%87%BA%E6%96%B9%E5%A1%8A%E7%9A%84-Android/1119_7.png" class="slug" width="324" height="666">

<p>「喔～ 原來如此」小威暗自說道。老皮接著說：「還有 status bar 上的方塊和圈圈，也很有趣：</p>
<img src="/%E8%B7%B3%E5%87%BA%E6%96%B9%E5%A1%8A%E7%9A%84-Android/1119_8.png" class="slug" width="324">

<p>這讓小威會心一笑，這搞笑的 App 通知方塊和圈圈他之前也遇過。小威記得自從 Android 5 開始後，就應使用單色透明背景的通知 icon，如果直接拿桌面用的 icon，或是其他全彩 icon，只會看到像上面截圖一樣，白色或黑色一塊一塊，完全不知道是哪個 App 來的通知。</p>
<h2 id="該怎麼做❔" class="heading-control"><a href="#該怎麼做❔" class="headerlink" title="該怎麼做❔"></a>該怎麼做❔<a class="heading-anchor" href="#該怎麼做❔" aria-hidden="true"></a></h2><p>雖然 icon 不能用全彩的，但是 Android 允許我們使用一個單色，給 icon 添點色彩，一般通常使用的是企業或產品的品牌色。</p>
<p>所以正確步驟：</p>
<ol>
<li><p>使用單色透明背景的 icon 如下，Android 系統會自動在一般模式、夜晚模式中幫我們調整顏色：</p>
<img src="/%E8%B7%B3%E5%87%BA%E6%96%B9%E5%A1%8A%E7%9A%84-Android/1119_9.png" class="slug">
</li>
<li><p>使用 NotificationCompat.Builder 的 <a href="https://developer.android.com/reference/androidx/core/app/NotificationCompat.Builder#setColor(int)">setColor</a> 指定想要用的單色：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> NotificationCompat.Builder(context, <span class="string">"channelId"</span>)</span><br><span class="line">     .setContentTitle(<span class="string">"title"</span>)</span><br><span class="line">     .setContentText(<span class="string">"message"</span>)</span><br><span class="line">     .setSmallIcon(R.drawable.ic_notify_icon)</span><br><span class="line">     .setColor(Color.RED)</span><br><span class="line">     .setContentIntent(pendingIntent).build();</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>差不多就這樣～ icon 也是產品的門面，共是使用在鎖頻介面中，用來判斷通知來源的方式，所以還是需要好好關注一下啊 😏</p>
<div>
    
        <div style="text-align:left;font-size:1em;">
<p style="text-align:center;color: #ccc;">------------- 本文结束 <i class="far fa-meh-rolling-eyes"></i> 我也要一個好 icon -------------</p>
        </div>
    
</div>
</body></html>]]></content>
      <categories>
        <category>小威</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 Android 憑證過期</title>
    <url>/%E9%97%9C%E6%96%BCAndroid%E6%86%91%E8%AD%89%E9%81%8E%E6%9C%9F/</url>
    <content><![CDATA[<html><head></head><body><h2 id="前言故事" class="heading-control"><a href="#前言故事" class="headerlink" title="前言故事"></a>前言故事<a class="heading-anchor" href="#前言故事" aria-hidden="true"></a></h2><p>最近網路新聞在流傳著一篇「Android 使用者注意！7.1.1 前舊機將不能正常瀏覽網頁」，小威的公司也對此在做一些可能的準備動作。之所以會對這議題這麼敏感，正是因為不久前，小威公司才因為 <a href="https://support.sectigo.com/articles/Knowledge/Sectigo-AddTrust-External-CA-Root-Expiring-May-30-2020">AddTrust External Root CA 過期</a>，換了自己網站的簽署 root CA 憑證，造成在 Android 5 以下的手機，使用 WebView 時發生錯誤…</p>
<h2 id="不建議的解決辦法" class="heading-control"><a href="#不建議的解決辦法" class="headerlink" title="不建議的解決辦法"></a>不建議的解決辦法<a class="heading-anchor" href="#不建議的解決辦法" aria-hidden="true"></a></h2><p>小威對這件事仍是記憶猶新，當時的解決辦法是，把新憑證一起打包進 App 中，使用 Android 更替 <a href="https://developer.android.com/reference/javax/net/ssl/X509TrustManager">X509TrustManager</a> 的方式，將需要允許連線的憑證包進去。</p>
<p>過程中，有個錯誤做法值得一提，因為網路上會搜尋到這種做法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// "信任全部的" X509TrustManager</span></span><br><span class="line"><span class="keyword">final</span> TrustManager[] tm =</span><br><span class="line">  <span class="keyword">new</span> TrustManager[] {</span><br><span class="line">    <span class="keyword">new</span> X509TrustManager() {</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">        <span class="comment">// 不做事就是默認信任</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">        <span class="comment">// 不做事就是默認信任</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> java.security.cert.X509Certificate[] {};</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">sslContext.init(<span class="keyword">null</span>, tm, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line"><span class="keyword">final</span> SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 準備建立 OkHttpClient</span></span><br><span class="line">OkHttpClient.Builder builder = ...</span><br><span class="line">builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) tm[<span class="number">0</span>]);</span><br><span class="line">OkHttpClient = builder.build();</span><br></pre></td></tr></tbody></table></figure>

<p>這是網路常見的做法之一，不建議的原因是還是安全性考量，默認相信所有憑證會讓惡意網頁有機可乘。</p>
<h2 id="更好的做法" class="heading-control"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法<a class="heading-anchor" href="#更好的做法" aria-hidden="true"></a></h2><p>小威團隊使用的做法是，建立一個全新的鏈狀 <code>X509TrustManager</code> 如下，它會先檢查 Android 系統憑證，再檢查公司的新憑證，除此之外的一率不放行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomX509TrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立憑證鏈，會依序檢查是否符合憑證</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List<X509TrustManager> trustManagers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TrustManager[] getTrustManagers(KeyStore keyStore) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TrustManager[] {<span class="keyword">new</span> CustomX509TrustManager(keyStore)};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomX509TrustManager</span><span class="params">(KeyStore keystore)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.trustManagers = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">    <span class="comment">// 加入原本的 TrustManager</span></span><br><span class="line">    <span class="keyword">this</span>.trustManagers.add(getDefaultTrustManager());</span><br><span class="line">    <span class="comment">// 加入指定 keystore TrustManager</span></span><br><span class="line">    <span class="keyword">this</span>.trustManagers.add(getTrustManager(keystore));</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">this</span>.trustManagers.add(trustManagerForCertificates(trustedCertificatesInputStream()));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="comment">// 無法添加我們自己的 cert，使用系統預設的</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">    <span class="keyword">for</span> (X509TrustManager trustManager : trustManagers) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        trustManager.checkClientTrusted(chain, authType);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 有其中一個 cert 通過，就當作通過</span></span><br><span class="line">      } <span class="keyword">catch</span> (CertificateException e) {</span><br><span class="line">        <span class="comment">// 這個不通過，換下一個</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CertificateException(<span class="string">"None of the TrustManagers trust this certificate chain"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">    <span class="keyword">for</span> (X509TrustManager trustManager : trustManagers) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        trustManager.checkServerTrusted(chain, authType);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 有其中一個 cert 通過，就當作通過</span></span><br><span class="line">      } <span class="keyword">catch</span> (CertificateException e) {</span><br><span class="line">        <span class="comment">// 這個不通過，換下一個</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CertificateException(<span class="string">"None of the TrustManagers trust this certificate chain"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() {</span><br><span class="line">    List<X509Certificate> certificates = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">    <span class="keyword">for</span> (X509TrustManager trustManager : trustManagers) {</span><br><span class="line">      certificates.addAll(Arrays.asList(trustManager.getAcceptedIssuers()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> certificates.toArray(<span class="keyword">new</span> X509Certificate[<span class="number">0</span>]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">getDefaultTrustManager</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getTrustManager(<span class="keyword">null</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">getTrustManager</span><span class="params">(KeyStore keystore)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getTrustManager(TrustManagerFactory.getDefaultAlgorithm(), keystore);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 只取出 keystore 中 X509 TrustManager</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">getTrustManager</span><span class="params">(String algorithm, KeyStore keystore)</span> </span>{</span><br><span class="line">    TrustManagerFactory factory;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      factory = TrustManagerFactory.getInstance(algorithm);</span><br><span class="line">      factory.init(keystore);</span><br><span class="line">      List<TrustManager> trustManagerList = Arrays.asList(factory.getTrustManagers());</span><br><span class="line">      List<X509TrustManager> x509TrustManagerList = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">      <span class="keyword">if</span> (trustManagerList != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (TrustManager tm : trustManagerList) {</span><br><span class="line">          <span class="keyword">if</span> (tm <span class="keyword">instanceof</span> X509TrustManager) {</span><br><span class="line">            x509TrustManagerList.add((X509TrustManager) tm);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (x509TrustManagerList.size() > <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> x509TrustManagerList.get(<span class="number">0</span>);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (NoSuchAlgorithmException | KeyStoreException e) {</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 將指定 InputStream 的的憑證建成 TrustManager</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">trustManagerForCertificates</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> GeneralSecurityException </span>{</span><br><span class="line">    CertificateFactory certificateFactory = CertificateFactory.getInstance(<span class="string">"X.509"</span>);</span><br><span class="line">    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);</span><br><span class="line">    <span class="keyword">if</span> (certificates.isEmpty()) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected empty InputStream"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立 keystore</span></span><br><span class="line">    <span class="keyword">char</span>[] password = <span class="string">"password"</span>.toCharArray(); <span class="comment">// Any password will work.</span></span><br><span class="line">    KeyStore keyStore = newEmptyKeyStore(password);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Certificate certificate : certificates) {</span><br><span class="line">      String certificateAlias = Integer.toString(index++);</span><br><span class="line">      keyStore.setCertificateEntry(certificateAlias, certificate);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 keystore 建立 TrustManager</span></span><br><span class="line">    KeyManagerFactory keyManagerFactory =</span><br><span class="line">        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">    keyManagerFactory.init(keyStore, password);</span><br><span class="line">    TrustManagerFactory trustManagerFactory =</span><br><span class="line">        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">    trustManagerFactory.init(keyStore);</span><br><span class="line">    List<TrustManager> trustManagerList = Arrays.asList(trustManagerFactory.getTrustManagers());</span><br><span class="line">    List<X509TrustManager> x509TrustManagerList = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">    <span class="keyword">if</span> (trustManagerList != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (TrustManager tm : trustManagerList) {</span><br><span class="line">        <span class="keyword">if</span> (tm <span class="keyword">instanceof</span> X509TrustManager) {</span><br><span class="line">          x509TrustManagerList.add((X509TrustManager) tm);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (x509TrustManagerList.size() > <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span> x509TrustManagerList.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> KeyStore <span class="title">newEmptyKeyStore</span><span class="params">(<span class="keyword">char</span>[] password)</span> <span class="keyword">throws</span> GeneralSecurityException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">      InputStream in = <span class="keyword">null</span>; <span class="comment">// By convention, 'null' creates an empty key store.</span></span><br><span class="line">      keyStore.load(in, password);</span><br><span class="line">      <span class="keyword">return</span> keyStore;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InputStream <span class="title">trustedCertificatesInputStream</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 憑證也能放在 resource 內，demo 放這容易看</span></span><br><span class="line">    String cert =</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">            + <span class="string">"-----BEGIN CERTIFICATE-----\n"</span></span><br><span class="line">            <span class="comment">// 憑證內容放這</span></span><br><span class="line">            + <span class="string">"-----END CERTIFICATE-----\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Buffer().writeUtf8(cert).inputStream();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上從 <a href="https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java">https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java</a> 變化而來</p>
<h2 id="其他做法" class="heading-control"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法<a class="heading-anchor" href="#其他做法" aria-hidden="true"></a></h2><p>小威之後又發現，okhttp 官方 github 也有類似的 sample，之後也許也能試試</p>
<p><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java">okhttp 官方 github CustomTrust.java</a></p>
<h2 id="關於-Android-7-1-1" class="heading-control"><a href="#關於-Android-7-1-1" class="headerlink" title="關於 Android 7.1.1"></a>關於 Android 7.1.1<a class="heading-anchor" href="#關於-Android-7-1-1" aria-hidden="true"></a></h2><p>至於 Android 7.1.1 版本之前的裝置呢？因為許多網站簽署的憑證即將到期，勢必會換成新的憑證，造成舊機 WebView 或瀏覽器可能不支援新的憑證，解決方法還是建議更新系統（如果可以的話），要不就是 App 要準備處理過期憑證的錯誤，適時提醒使用者憑證問題，以及建議的解決方式，避免一開啟網頁就遇到一片空白，甚至 App 強制關閉 😖</p>
<p>另一個小威在思索的事情是，非自己產品的相關的網頁，是否該用 WebView 開啟？嚴格來說其實不應該，因為不清楚其他人會在相關網頁內，做什麼事情，尤其時當開啟 JavaScript 後，這個問題更值得所有用 App WebView 去開啟第三方網頁的團隊去思索～</p>
<hr>
<p><strong>相關連結：</strong><a href="https://gist.github.com/HughJeffner/6eac419b18c6001aeadb"><i class="fab fa-github"></i> CompositeTrustManager</a>, <a href="https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java"><i class="fas fa-code"></i> okhttp customizing trusted certificates</a>, <a href="https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java"><i class="fab fa-github"></i> okhttp customizing trusted certificates</a></p>
<div>
    
        <div style="text-align:left;font-size:1em;">
<p style="text-align:center;color: #ccc;">------------- 本文结束 <i class="far fa-question-circle"></i> App minSdkVersion 到底什麼時候才能提升啊 -------------</p>
        </div>
    
</div>
</body></html>]]></content>
      <categories>
        <category>小威</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
