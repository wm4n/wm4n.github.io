<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Story</title>
  
  <subtitle>在黑暗中寫故事 👻</subtitle>
  <link href="https://wm4n.github.io/atom.xml" rel="self"/>
  
  <link href="https://wm4n.github.io/"/>
  <updated>2020-11-11T05:51:24.073Z</updated>
  <id>https://wm4n.github.io/</id>
  
  <author>
    <name>William</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>關於 Android 憑證過期</title>
    <link href="https://wm4n.github.io/%E9%97%9C%E6%96%BCAndroid%E6%86%91%E8%AD%89%E9%81%8E%E6%9C%9F/"/>
    <id>https://wm4n.github.io/%E9%97%9C%E6%96%BCAndroid%E6%86%91%E8%AD%89%E9%81%8E%E6%9C%9F/</id>
    <published>2020-11-10T15:28:56.000Z</published>
    <updated>2020-11-11T05:51:24.073Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言故事" class="heading-control"><a href="#前言故事" class="headerlink" title="前言故事"></a>前言故事<a class="heading-anchor" href="#前言故事" aria-hidden="true"></a></h2><p>最近網路新聞在流傳著一篇「Android 使用者注意！7.1.1 前舊機將不能正常瀏覽網頁」，小威的公司也對此在做一些可能的準備動作。之所以會對這議題這麼敏感，正是因為不久前，小威公司才因為 <a href="https://support.sectigo.com/articles/Knowledge/Sectigo-AddTrust-External-CA-Root-Expiring-May-30-2020">AddTrust External Root CA 過期</a>，換了自己網站的簽署 root CA 憑證，造成在 Android 5 以下的手機，使用 WebView 時發生錯誤…</p><h2 id="不建議的解決辦法" class="heading-control"><a href="#不建議的解決辦法" class="headerlink" title="不建議的解決辦法"></a>不建議的解決辦法<a class="heading-anchor" href="#不建議的解決辦法" aria-hidden="true"></a></h2><p>小威對這件事仍是記憶猶新，當時的解決辦法是，把新憑證一起打包進 App 中，使用 Android 更替 <a href="https://developer.android.com/reference/javax/net/ssl/X509TrustManager">X509TrustManager</a> 的方式，將需要允許連線的憑證包進去。</p><p>過程中，有個錯誤做法值得一提，因為網路上會搜尋到這種做法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "信任全部的" X509TrustManager</span></span><br><span class="line"><span class="keyword">final</span> TrustManager[] tm =</span><br><span class="line">  <span class="keyword">new</span> TrustManager[] {</span><br><span class="line">    <span class="keyword">new</span> X509TrustManager() {</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">        <span class="comment">// 不做事就是默認信任</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">        <span class="comment">// 不做事就是默認信任</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> java.security.cert.X509Certificate[] {};</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">sslContext.init(<span class="keyword">null</span>, tm, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line"><span class="keyword">final</span> SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 準備建立 OkHttpClient</span></span><br><span class="line">OkHttpClient.Builder builder = ...</span><br><span class="line">builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) tm[<span class="number">0</span>]);</span><br><span class="line">OkHttpClient = builder.build();</span><br></pre></td></tr></tbody></table></figure><p>這是網路常見的做法之一，不建議的原因是還是安全性考量，默認相信所有憑證會讓惡意網頁有機可乘。</p><h2 id="更好的做法" class="heading-control"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法<a class="heading-anchor" href="#更好的做法" aria-hidden="true"></a></h2><p>小威團隊使用的做法是，建立一個全新的鏈狀 <code>X509TrustManager</code> 如下，它會先檢查 Android 系統憑證，再檢查公司的新憑證，除此之外的一率不放行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomX509TrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立憑證鏈，會依序檢查是否符合憑證</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List<X509TrustManager> trustManagers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TrustManager[] getTrustManagers(KeyStore keyStore) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TrustManager[] {<span class="keyword">new</span> CustomX509TrustManager(keyStore)};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomX509TrustManager</span><span class="params">(KeyStore keystore)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.trustManagers = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">    <span class="comment">// 加入原本的 TrustManager</span></span><br><span class="line">    <span class="keyword">this</span>.trustManagers.add(getDefaultTrustManager());</span><br><span class="line">    <span class="comment">// 加入指定 keystore TrustManager</span></span><br><span class="line">    <span class="keyword">this</span>.trustManagers.add(getTrustManager(keystore));</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">this</span>.trustManagers.add(trustManagerForCertificates(trustedCertificatesInputStream()));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="comment">// 無法添加我們自己的 cert，使用系統預設的</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">    <span class="keyword">for</span> (X509TrustManager trustManager : trustManagers) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        trustManager.checkClientTrusted(chain, authType);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 有其中一個 cert 通過，就當作通過</span></span><br><span class="line">      } <span class="keyword">catch</span> (CertificateException e) {</span><br><span class="line">        <span class="comment">// 這個不通過，換下一個</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CertificateException(<span class="string">"None of the TrustManagers trust this certificate chain"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">    <span class="keyword">for</span> (X509TrustManager trustManager : trustManagers) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        trustManager.checkServerTrusted(chain, authType);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 有其中一個 cert 通過，就當作通過</span></span><br><span class="line">      } <span class="keyword">catch</span> (CertificateException e) {</span><br><span class="line">        <span class="comment">// 這個不通過，換下一個</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CertificateException(<span class="string">"None of the TrustManagers trust this certificate chain"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() {</span><br><span class="line">    List<X509Certificate> certificates = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">    <span class="keyword">for</span> (X509TrustManager trustManager : trustManagers) {</span><br><span class="line">      certificates.addAll(Arrays.asList(trustManager.getAcceptedIssuers()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> certificates.toArray(<span class="keyword">new</span> X509Certificate[<span class="number">0</span>]);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">getDefaultTrustManager</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getTrustManager(<span class="keyword">null</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">getTrustManager</span><span class="params">(KeyStore keystore)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getTrustManager(TrustManagerFactory.getDefaultAlgorithm(), keystore);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 只取出 keystore 中 X509 TrustManager</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">getTrustManager</span><span class="params">(String algorithm, KeyStore keystore)</span> </span>{</span><br><span class="line">    TrustManagerFactory factory;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      factory = TrustManagerFactory.getInstance(algorithm);</span><br><span class="line">      factory.init(keystore);</span><br><span class="line">      List<TrustManager> trustManagerList = Arrays.asList(factory.getTrustManagers());</span><br><span class="line">      List<X509TrustManager> x509TrustManagerList = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">      <span class="keyword">if</span> (trustManagerList != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (TrustManager tm : trustManagerList) {</span><br><span class="line">          <span class="keyword">if</span> (tm <span class="keyword">instanceof</span> X509TrustManager) {</span><br><span class="line">            x509TrustManagerList.add((X509TrustManager) tm);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (x509TrustManagerList.size() > <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> x509TrustManagerList.get(<span class="number">0</span>);</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (NoSuchAlgorithmException | KeyStoreException e) {</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 將指定 InputStream 的的憑證建成 TrustManager</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> X509TrustManager <span class="title">trustManagerForCertificates</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> GeneralSecurityException </span>{</span><br><span class="line">    CertificateFactory certificateFactory = CertificateFactory.getInstance(<span class="string">"X.509"</span>);</span><br><span class="line">    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);</span><br><span class="line">    <span class="keyword">if</span> (certificates.isEmpty()) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected empty InputStream"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立 keystore</span></span><br><span class="line">    <span class="keyword">char</span>[] password = <span class="string">"password"</span>.toCharArray(); <span class="comment">// Any password will work.</span></span><br><span class="line">    KeyStore keyStore = newEmptyKeyStore(password);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Certificate certificate : certificates) {</span><br><span class="line">      String certificateAlias = Integer.toString(index++);</span><br><span class="line">      keyStore.setCertificateEntry(certificateAlias, certificate);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 keystore 建立 TrustManager</span></span><br><span class="line">    KeyManagerFactory keyManagerFactory =</span><br><span class="line">        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">    keyManagerFactory.init(keyStore, password);</span><br><span class="line">    TrustManagerFactory trustManagerFactory =</span><br><span class="line">        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">    trustManagerFactory.init(keyStore);</span><br><span class="line">    List<TrustManager> trustManagerList = Arrays.asList(trustManagerFactory.getTrustManagers());</span><br><span class="line">    List<X509TrustManager> x509TrustManagerList = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">    <span class="keyword">if</span> (trustManagerList != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (TrustManager tm : trustManagerList) {</span><br><span class="line">        <span class="keyword">if</span> (tm <span class="keyword">instanceof</span> X509TrustManager) {</span><br><span class="line">          x509TrustManagerList.add((X509TrustManager) tm);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (x509TrustManagerList.size() > <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span> x509TrustManagerList.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> KeyStore <span class="title">newEmptyKeyStore</span><span class="params">(<span class="keyword">char</span>[] password)</span> <span class="keyword">throws</span> GeneralSecurityException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">      InputStream in = <span class="keyword">null</span>; <span class="comment">// By convention, 'null' creates an empty key store.</span></span><br><span class="line">      keyStore.load(in, password);</span><br><span class="line">      <span class="keyword">return</span> keyStore;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InputStream <span class="title">trustedCertificatesInputStream</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 憑證也能放在 resource 內，demo 放這容易看</span></span><br><span class="line">    String cert =</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">            + <span class="string">"-----BEGIN CERTIFICATE-----\n"</span></span><br><span class="line">            <span class="comment">// 憑證內容放這</span></span><br><span class="line">            + <span class="string">"-----END CERTIFICATE-----\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Buffer().writeUtf8(cert).inputStream();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上從 <a href="https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java">https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java</a> 變化而來</p><h2 id="其他做法" class="heading-control"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法<a class="heading-anchor" href="#其他做法" aria-hidden="true"></a></h2><p>小威之後又發現，okhttp 官方 github 也有類似的 sample，之後也許也能試試</p><p><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java">okhttp 官方 github CustomTrust.java</a></p><h2 id="關於-Android-7-1-1" class="heading-control"><a href="#關於-Android-7-1-1" class="headerlink" title="關於 Android 7.1.1"></a>關於 Android 7.1.1<a class="heading-anchor" href="#關於-Android-7-1-1" aria-hidden="true"></a></h2><p>至於 Android 7.1.1 版本之前的裝置呢？因為許多網站簽署的憑證即將到期，勢必會換成新的憑證，造成舊機 WebView 或瀏覽器可能不支援新的憑證，解決方法還是建議更新系統（如果可以的話），要不就是 App 要準備處理過期憑證的錯誤，適時提醒使用者憑證問題，以及建議的解決方式，避免一開啟網頁就遇到一片空白，甚至 App 強制關閉 😖</p><p>另一個小威在思索的事情是，非自己產品的相關的網頁，是否該用 WebView 開啟？嚴格來說其實不應該，因為不清楚其他人會在相關網頁內，做什麼事情，尤其時當開啟 JavaScript 後，這個問題更值得所有用 App WebView 去開啟第三方網頁的團隊去思索～</p><hr><p><strong>相關連結：</strong><a href="https://gist.github.com/HughJeffner/6eac419b18c6001aeadb"><i class="fab fa-github"></i> CompositeTrustManager</a>, <a href="https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java"><i class="fas fa-code"></i> okhttp customizing trusted certificates</a>, <a href="https://square.github.io/okhttp/https/#customizing-trusted-certificates-kt-java"><i class="fab fa-github"></i> okhttp customizing trusted certificates</a></p><div>            <div style="text-align:left;font-size:1em;"><p style="text-align:center;color: #ccc;">------------- 本文结束 <i class="far fa-question-circle"></i> App minSdkVersion 到底什麼時候才能提升啊 -------------</p>        </div>    </div></body></html>]]></content>
    
    
    <summary type="html">最近網路新聞在流傳著一篇「Android 使用者注意！7.1.1 前舊機將不能正常瀏覽網頁」，小威的公司也對此在做一些可能的準備動作。之所以會對這議題這麼敏感，正是因為不久前，小威公司才因為 AddTrust External Root CA 過期，換了自己網站的簽署 root CA 憑證，造成在 Android 5 以下的手機，使用 WebView 時發生錯誤...</summary>
    
    
    
    <category term="小威" scheme="https://wm4n.github.io/categories/%E5%B0%8F%E5%A8%81/"/>
    
    <category term="android" scheme="https://wm4n.github.io/categories/%E5%B0%8F%E5%A8%81/android/"/>
    
    
    <category term="android" scheme="https://wm4n.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>git submodule 的分支追蹤</title>
    <link href="https://wm4n.github.io/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/"/>
    <id>https://wm4n.github.io/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/</id>
    <published>2020-10-31T19:24:47.000Z</published>
    <updated>2020-11-11T05:51:24.069Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言故事" class="heading-control"><a href="#前言故事" class="headerlink" title="前言故事"></a>前言故事<a class="heading-anchor" href="#前言故事" aria-hidden="true"></a></h2><p>小威在一間資訊公司擔任 Android 軟體工程師，負責公司內的主力產品開發，這是一項功能複雜的產品，它累計了數年的程式碼、商務邏輯、出包經驗等的功能與修正。數年後，團隊中正在推動全新 2.0 的產品，以及公司其他服務也即將推出 App。不可避免的，有許多相似功能相繼橫跨各個產品 App，這讓小威自覺必須有一套更好的方式管理自己團隊的程式碼，改善之後擴充性、維護性，和保護團隊工程師們的肝～</p><p>一個從頭打造的產品，功能是不斷的疊加上去，鮮少有團隊能真的從開頭就搞好架構設計，小威團隊的產品也不例外。除了自身的核心功能外，還使用了圖隊之前開發的功能，以及許多現成 github 的模組，有的已提供 gradle 的安裝與使用，有的卻只是單純的 Java/Kotlin 程式碼。在初期，最直接暴力的方式就是直接抓下來，塞進當前的 App 中使用，累積到今時今日，已有數個相同模組，分別的複製到數個專案上 😱</p><p>小威團隊有幾個選擇：</p><ol><li>維持現狀，每個 App 複製一份程式碼<ul><li><strong>優點</strong>：現有架構、不需更改、各個 App 工程彈性自由，想怎麼改就怎麼改</li><li><strong>缺點</strong>：維上非常不便，一個修正需要同步到所有 App，之後工程師要記得去手動 merge 更新的程式碼</li></ul></li></ol><ol start="2"><li>將可模組化的，改寫成 gradle<ul><li><strong>優點</strong>：不必要再包一份程式碼到各個 App，之後其他專案要使用會更便利。模組更新，只需要修改一份程式碼，gradle 版號升級便可更新程式</li><li><strong>缺點</strong>：之後各個 App 要做客製化，會相對不容易</li></ul></li></ol><ol start="3"><li>將可模組化的，改成 submodule<ul><li><strong>優點</strong>：每個模組只需要維護一份程式碼，需要更新時，使用 git 內建方式，即可同步最新的程式。App 也有一定自由度去做產品客製化</li><li><strong>缺點</strong>：還是仰賴各 App 去 merge 更新，但不一定需要手動（透過 git 同步 submodule 即可）</li></ul></li></ol><p>最後，小威團隊選擇 submodule 模式去進行，以下是小威的手稿紀錄：</p><h2 id="將專案切分成-submodule" class="heading-control"><a href="#將專案切分成-submodule" class="headerlink" title="將專案切分成 submodule"></a>將專案切分成 submodule<a class="heading-anchor" href="#將專案切分成-submodule" aria-hidden="true"></a></h2><p>目前小威團隊負責的產品 git 架構如下，一個巨型 git repo，內容包山包海，含之前團隊開發的功能模組，以及第三方 github 的功能模組等：</p><img src="/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/app_diagram_1.svg" class title="產品架構圖 - 之前"><p>重新打造後，新的 git 架構如下，可被多個產品共用的模組，都會拉成獨立的 git repo，由一個主要 git repo 來把其他功能，以 submodule 方式添加進來：</p><img src="/git-submodule-%E7%9A%84%E5%88%86%E6%94%AF%E8%BF%BD%E8%B9%A4/app_diagram_2.svg" class title="產品架構圖 - 之後"><h3 id="加入-submodule-指令" class="heading-control"><a href="#加入-submodule-指令" class="headerlink" title="加入 submodule 指令"></a>加入 submodule 指令<a class="heading-anchor" href="#加入-submodule-指令" aria-hidden="true"></a></h3><p>以下用其中一個功能為範例。將 function1 以 submodule 方式加入主 App：</p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git submodule add https://github.com/wm4n/function1.gitfunction1</span><br><span class="line">正複製到 <span class="string">'/Users/[path]/app-host/function1'</span>...</span><br><span class="line">remote: Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">接收物件中: 100% (4/4), 完成.</span><br></pre></td></tr></tbody></table></figure><p>以上指令會將 function1 repo 內容抓到 function1 目錄下，如果印出 .gitmodules 檔案（使用 <code>git submodule add</code> 後自動建立）內容，會發現：</p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"function1"</span>]</span><br><span class="line">path = function1</span><br><span class="line">url = https://github.com/wm4n/function1.git</span><br></pre></td></tr></tbody></table></figure><h3 id="上傳添加的-submodule" class="heading-control"><a href="#上傳添加的-submodule" class="headerlink" title="上傳添加的 submodule"></a>上傳添加的 submodule<a class="heading-anchor" href="#上傳添加的-submodule" aria-hidden="true"></a></h3><p>照平常 git 使用的方式，將添加好的 submodule 設定，上傳至 github</p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git add .gitmodules</span><br><span class="line"></span><br><span class="line">❯ git add function1</span><br><span class="line"></span><br><span class="line">❯ git commit -m <span class="string">"add function1 submodule"</span></span><br><span class="line">[main 26d42dc] add function1 submodule</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 function1</span><br><span class="line"></span><br><span class="line">❯ git push</span><br><span class="line">枚舉物件: 4, 完成.</span><br><span class="line">物件計數中: 100% (4/4), 完成.</span><br><span class="line">使用 4 個執行緒進行壓縮</span><br><span class="line">壓縮物件中: 100% (3/3), 完成.</span><br><span class="line">寫入物件中: 100% (3/3), 419 位元組 | 419.00 KiB/s, 完成.</span><br><span class="line">總共 3 (差異 0)，復用 0 (差異 0)，重用包 0</span><br><span class="line">To https://github.com/wm4n/app-host.git</span><br><span class="line">   278058e..26d42dc  main -> main</span><br></pre></td></tr></tbody></table></figure><h3 id="更新-repo-內容" class="heading-control"><a href="#更新-repo-內容" class="headerlink" title="更新 repo 內容"></a>更新 repo 內容<a class="heading-anchor" href="#更新-repo-內容" aria-hidden="true"></a></h3><p>當要同步線上程式碼時，一般會用 <code>git pull</code> 來抓取最新內容，但改用 submodule 方式後，會發現 function1 不會同步。如果要更新，則必須進入到 function1 目錄下再次執行 <code>git pull</code></p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> function1</span><br><span class="line"></span><br><span class="line">❯ git pull</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">展開物件中: 100% (3/3), 691 位元組 | 138.00 KiB/s, 完成.</span><br><span class="line">來自 https://github.com/wm4n/function1</span><br><span class="line">   5f9ae22..e6843b4  main       -> origin/main</span><br><span class="line">更新 5f9ae22..e6843b4</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></tbody></table></figure><h3 id="當-submodule-數量成長後" class="heading-control"><a href="#當-submodule-數量成長後" class="headerlink" title="當 submodule 數量成長後"></a>當 submodule 數量成長後<a class="heading-anchor" href="#當-submodule-數量成長後" aria-hidden="true"></a></h3><p>小威團隊負責的產品，如今被拆解成 5 個 submodule 後，發現今後如果要更新，就要進入每個 submodule 的目錄，分別執行 <code>git pull</code> 指令，這表示一個專案如果有 X 個 submodule，每次更新最多就會有 X + 1 個 <code>git pull</code>。這不僅讓小威受不了，團隊也常為了忘記要確實執行，反而造成許多問題。</p><p>為了改善這問題，小威在模組設定檔中，<strong>指定讓模組 submodule 追蹤某個特定的遠端分支</strong></p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"function1"</span>]</span><br><span class="line">path = function1</span><br><span class="line">url = https://wm4n@github.com/wm4n/function1.git</span><br><span class="line">branch = main</span><br></pre></td></tr></tbody></table></figure><p>branch 代表這個 submodule 將追蹤指定的遠端分支。之後，團隊只要使用 <code>git submodule update --remote</code> 指令<strong>一次</strong>，所有的 submodule 都會依照指定的<strong>分支</strong>去抓最新的內容，如下：</p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git submodule update --remote</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">展開物件中: 100% (3/3), 689 位元組 | 344.00 KiB/s, 完成.</span><br><span class="line">來自 https://github.com/wm4n/function1</span><br><span class="line">   e6843b4..c7df259  main       -> origin/main</span><br><span class="line">子模組路徑 <span class="string">'function1'</span>：檢出 <span class="string">'c7df259c57f4c6143c4e29488399b13b9fb188c6'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="令人分心的-git-status" class="heading-control"><a href="#令人分心的-git-status" class="headerlink" title="令人分心的 git status"></a>令人分心的 git status<a class="heading-anchor" href="#令人分心的-git-status" aria-hidden="true"></a></h3><p>一切設定好，分支追蹤功能滿足了團隊的需求，從此之後，可重複使用的功能順利地抽出成獨立 git repo，不同 App 依照各自需求，添加自己需要的 submodule，然後一鍵更新所有模組也不再是夢想 🥳。一切是如此的美好，直到團隊發現… 經常 <code>git status</code>，就會出現：</p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ git status</span><br><span class="line">位於分支 main</span><br><span class="line">您的分支與上游分支 <span class="string">'origin/main'</span> 一致。</span><br><span class="line"></span><br><span class="line">尚未暫存以備提交的變更：</span><br><span class="line">  （使用 <span class="string">"git add <檔案>..."</span> 更新要提交的內容）</span><br><span class="line">  （使用 <span class="string">"git restore <檔案>..."</span> 捨棄工作區的改動）</span><br><span class="line">修改：     function1 (新提交)</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">"git add"</span> 和/或 <span class="string">"git commit -a"</span>）</span><br></pre></td></tr></tbody></table></figure><p>在使用分支追蹤之前，小威的團隊總是會在跟新模組後，緊接著跟新主 App 的模組 commit ID。使用分支追蹤後，雖然不必要再跟新模組 commit ID（因為 <code>git submodule update --remote</code> 指令會自動同步分支最新的 commit ID），但 <code>git status</code> 指令還是會提醒有更新尚未提交。久而久之，團隊都覺得這訊息實在惱人啊～ 😖</p><p>小威試了數個方式後，包括把相關檔案都加到 <code>.gitignore</code>（此方法無效），最後是在模組設定中，加上 <code>ignore = all</code>，就搞定了：</p><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">❯ cat .gitmodules</span><br><span class="line">[submodule <span class="string">"function1"</span>]</span><br><span class="line">path = function1</span><br><span class="line">url = https://wm4n@github.com/wm4n/function1.git</span><br><span class="line">branch = main</span><br><span class="line">ignore = all</span><br></pre></td></tr></tbody></table></figure><h3 id="對-github-上的第三方專案做客製化" class="heading-control"><a href="#對-github-上的第三方專案做客製化" class="headerlink" title="對 github 上的第三方專案做客製化"></a>對 github 上的第三方專案做客製化<a class="heading-anchor" href="#對-github-上的第三方專案做客製化" aria-hidden="true"></a></h3><p>沒多久後，小威團隊發現，他們想對 github 上的第三方專案做客製化，以符合規格需求，但要如何追蹤 github 專案分支的同時，又做客製化呢？畢竟無法對第三方的專案做修改（除非經由 PR 流程，但一般來說不會接受客製化…）</p><p>小威團隊利用 github fork 專案的方式，讓自己的專案轉追蹤 fork 的拷貝，利用 fork 拷貝來做客製化，同時又能<a href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/syncing-a-fork">不斷從 upstream 專案中更新</a></p><hr><p>從此之後，<code>git status</code> 也不再困擾小威團隊了 🥳</p><p><strong>相關連結：</strong><a href="https://github.com/wm4n/app-host"><i class="fab fa-github"></i> Demo 專案</a></p><div>            <div style="text-align:left;font-size:1em;"><p style="text-align:center;color: #ccc;">------------- 本文结束 <i class="fab fa-git-alt"></i> git 就是這麼的難搞！-------------</p>        </div>    </div></body></html>]]></content>
    
    
    <summary type="html">某天的上班的早晨，小威突然被叫進會議室，會議中說明，小威公司已確定為目前主力產品 App 推出新的版本，但當前的舊版仍需繼續維運，直到新版的各項指標皆達成預期。這消息一方面令人振奮，因為公司正朝 App 轉型的方向前進，但另一方面也令小威團隊擔憂，原因是同時開發新版本，與維運舊版，這段時間將耗費大量的人力資源。 &lt;br/&gt;&lt;br/&gt; 小威團隊使用 submodule 的方式，提高兩個 App 的程式碼共用率，並把 submodule 使用的方式記錄在此篇...</summary>
    
    
    
    <category term="小威" scheme="https://wm4n.github.io/categories/%E5%B0%8F%E5%A8%81/"/>
    
    <category term="git" scheme="https://wm4n.github.io/categories/%E5%B0%8F%E5%A8%81/git/"/>
    
    
    <category term="git" scheme="https://wm4n.github.io/tags/git/"/>
    
  </entry>
  
</feed>
